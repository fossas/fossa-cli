{-# LANGUAGE RecordWildCards #-}

module App.Fossa.Analyze.VulnerabilityReport (
  logVulnerabilityReport,
) where

import App.Fossa.Analyze.Project (ProjectResult (..))
import Control.Algebra (Has)
import Control.Effect.Diagnostics qualified as Diag (Diagnostics)
import Data.Foldable (traverse_)
import Data.List qualified as List
import Data.Maybe qualified
import Data.Set qualified as Set
import Data.String.Conversion (toString, toText)
import Data.Text (Text)
import Data.Text qualified as Text
import DepTypes (Dependency (..), VerConstraint)
import Effect.Logger (
  Logger,
  logInfo,
 )
import Graphing (directList, getRootsOf, vertexList)
import Path (File, SomeBase)
import Prettyprinter (Pretty (pretty), vsep)
import Srclib.Converter (verConstraintToRevision)
import Text.PrettyPrint.Boxes qualified as Boxes

data VulnerableDependency = VulnerableDependency
  { vdName :: Text
  , isVulnerable :: Maybe VerConstraint -> Bool
  }

data VulnerableDependencyOrigin
  = VulnerableDependencyManifestFiles [SomeBase File]
  | VulnerableDependencyRootDependency [Dependency]
  deriving (Eq, Ord)

instance Show VulnerableDependencyOrigin where
  show (VulnerableDependencyManifestFiles files) = toString $ Text.intercalate ", " (map (toText . show) files)
  show (VulnerableDependencyRootDependency deps) = toString (Text.intercalate ", " $ map dependencyName deps)

data VulnerableReportItem = VulnerableReportItem
  { vriDep :: Dependency
  , vriDepOriginDep :: VulnerableDependencyOrigin
  }
  deriving (Eq, Ord)

-- HACK - Please FIX ASAP!
-- Since we do not have built in version evaluator system, nor we parse version text into representative form.
-- This is simplest of hack, ideally each versions are listed as opposed to providing evaluator functions.
allVersionsBelow2_17 :: Maybe VerConstraint -> Bool
allVersionsBelow2_17 version = case verConstraintToRevision =<< version of
  Nothing -> False
  Just ver -> any (\v -> v `Text.isPrefixOf` ver) below2_17
    where
      below2_17 :: [Text] = ["1."] ++ map ("2." <>) (map (toText . show) (takeWhile (<= (16 :: Int)) $ iterate (+ 1) 0))

getVulnerableDeps :: [VulnerableDependency]
getVulnerableDeps =
  [ VulnerableDependency "org.apache.logging.log4j:log4j-core" allVersionsBelow2_17
  , VulnerableDependency "org.apache.logging.log4j:log4j" allVersionsBelow2_17
  , VulnerableDependency "log4j:log4j" (allVersionsBelow2_17)
  ]

logVulnerabilityReport :: (Has Diag.Diagnostics sig m, Has Logger sig m) => [ProjectResult] -> m ()
logVulnerabilityReport = traverse_ printProjectReport

printProjectReport :: (Has Diag.Diagnostics sig m, Has Logger sig m) => ProjectResult -> m ()
printProjectReport ProjectResult{..} =
  logInfo $
    vsep
      [ ""
      , "Project Path: " <> (pretty . show $ projectResultPath)
      , "Dependencies: "
      , ""
      , pretty renderedReport
      ]
  where
    renderedReport :: String
    renderedReport =
      Boxes.render
        . Boxes.hsep 2 Boxes.left
        . map (Boxes.vcat Boxes.left . map Boxes.text)
        $ table

    table :: [[String]]
    table =
      List.transpose
        ( [ ["Name", "Version", "Vulnerable?", "Type", "Environment", "Origin (manifest files if direct dependency, otherwise responsible direct dependency)"]
          , ["----", "-------", "-----------", "----", "-----------", "------------------------------------------------------------------------------------"]
          ]
            <> [ [ toString . dependencyName $ vriDep reportItem
                 , toString . showDepVersion . dependencyVersion . vriDep $ reportItem
                 , if hasVulnerability . vriDep $ reportItem then "Vulnerable" else "N/A"
                 , toString . showDepType . vriDep $ reportItem
                 , toString . showDepEnv . vriDep $ reportItem
                 , show . vriDepOriginDep $ reportItem
                 ]
               | reportItem <- reportItems
               ]
        )

    reportItems :: [VulnerableReportItem]
    reportItems =
      map toVulnerableReportItem $
        filter isRelevantDep (vertexList projectResultGraph)

    isRelevantDep :: Dependency -> Bool
    isRelevantDep Dependency{..} =
      any
        (\vd -> dependencyName == vdName vd)
        getVulnerableDeps

    toVulnerableReportItem :: Dependency -> VulnerableReportItem
    toVulnerableReportItem dep =
      VulnerableReportItem
        dep
        ( if dep `elem` directList projectResultGraph
            then VulnerableDependencyManifestFiles projectResultManifestFiles
            else VulnerableDependencyRootDependency (getRootsOf projectResultGraph dep)
        )

    hasVulnerability :: Dependency -> Bool
    hasVulnerability Dependency{..} =
      any (\vd -> dependencyName == vdName vd && isVulnerable vd dependencyVersion) getVulnerableDeps

    showDepType :: Dependency -> Text
    showDepType dep =
      if dep `elem` directList projectResultGraph
        then "Direct"
        else "Indirect"

    showDepVersion :: Maybe VerConstraint -> Text
    showDepVersion vc = Data.Maybe.fromMaybe "N/A" (verConstraintToRevision =<< vc)

    showDepEnv :: Dependency -> Text
    showDepEnv dep = Text.intercalate ", " $ map (toText . show) (Set.toList $ dependencyEnvironments dep)
