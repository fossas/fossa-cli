package config

import (
	"io/ioutil"
	"strings"

	"github.com/apex/log"
	"github.com/urfave/cli"
	yaml "gopkg.in/yaml.v2"

	"github.com/fossas/fossa-cli/cmd/fossa/flags"
	v1 "github.com/fossas/fossa-cli/config/file.v1"
	"github.com/fossas/fossa-cli/errors"
	"github.com/fossas/fossa-cli/files"
	"github.com/fossas/fossa-cli/module"
)

// File defines the minimum interface for usage as a configuration file. We use
// an interface here in anticipation of new versions of configuration files,
// which will likely be implemented as different structs.
type File interface {
	APIKey() string
	Server() string

	Title() string
	Fetcher() string
	Project() string
	Branch() string
	Revision() string

	Modules() []module.Module
}

type NoFile struct{}

func (_ NoFile) APIKey() string {
	return ""
}

func (_ NoFile) Server() string {
	return ""
}

func (_ NoFile) Title() string {
	return ""
}

func (_ NoFile) Fetcher() string {
	return ""
}

func (_ NoFile) Project() string {
	return ""
}

func (_ NoFile) Branch() string {
	return ""
}

func (_ NoFile) Revision() string {
	return ""
}

func (_ NoFile) Modules() []module.Module {
	return []module.Module{}
}

// InitFile writes the current configuration to the current configuration file
// path.
func InitFile(modules []module.Module) File {
	// Construct module configs.
	var configs []v1.ModuleProperties
	for _, m := range modules {
		configs = append(configs, v1.ModuleProperties{
			Name:        m.Name,
			Type:        m.Type.String(),
			BuildTarget: m.BuildTarget,
			Path:        m.Dir,
			Options:     m.Options,
			Ignore:      m.Ignore,
		})
	}

	// Construct configuration file.
	return v1.File{
		Version: 1,
		CLI: v1.CLIProperties{
			Server:  Endpoint(),
			Fetcher: Fetcher(),
			Project: Project(),
		},
		Analyze: v1.AnalyzeProperties{
			Modules: configs,
		},
	}
}

// ReadFile reads the configuration file specified by CLI flags.
func ReadFile(c *cli.Context) (File, string, error) {
	// Find a configuration file if one exists.
	flag := ctx.String(flags.Config)
	log.WithField("filename", flag).Debug("reading configuration file")
	filename, err := TryFiles(flag, ".fossa.yml", ".fossa.yaml")
	if err == ErrFileNotFound {
		return NoFile{}, ".fossa.yml", nil
	}
	if err != nil {
		return NoFile{}, ".fossa.yml", err
	}

	// Try to unmarshal the configuration file into a known config file version.
	data, err := files.Read(filename)
	if err != nil {
		return NoFile{}, filename, err
	}
	file, err := v1.New(data)
	if err != nil {
		return NoFile{}, filename, err
	}
	return file, filename, err
}

func WriteFile(modules []module.Module) error {
	file := InitFile(modules)

	// Write file with header.
	data, err := yaml.Marshal(file)
	if err != nil {
		return err
	}
	configHeader := []byte(
		strings.Join([]string{
			"# Generated by FOSSA CLI (https://github.com/fossas/fossa-cli)",
			"# Visit https://fossa.io to learn more",
			"",
			"",
		}, "\n"))
	return ioutil.WriteFile(Filepath(), append(configHeader, data...), 0777)
}

func UpdateFile(modules []module.Module) error {
	return errors.ErrNotImplemented
}

func ExistsFile() (bool, error) {
	return files.Exists(Filepath())
}
