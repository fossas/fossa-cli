package report

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	"github.com/apex/log"
	"github.com/olekukonko/tablewriter"
	"github.com/urfave/cli"

	"github.com/fossas/fossa-cli/api/fossa"
	"github.com/fossas/fossa-cli/cmd/fossa/display"
	"github.com/fossas/fossa-cli/cmd/fossa/flags"
	"github.com/fossas/fossa-cli/cmd/fossa/setup"
	"github.com/fossas/fossa-cli/config"
	"github.com/fossas/fossa-cli/errors"
)

const attributionTemplate = `Generated by fossa-cli (https://github.com/fossas/fossa-cli).
Attribution for project %s, revision %s
Direct Dependencies
%s
Deep Dependencies
%s`

var attributionCmd = cli.Command{
	Name:  "attribution",
	Usage: "Generate attribution report",
	Flags: flags.WithGlobalFlags(flags.WithAPIFlags(flags.WithOptions(flags.WithReportTemplateFlags([]cli.Flag{
		cli.BoolFlag{Name: JSON, Usage: "format output as JSON"},
	})))),
	Action: generateReport,
}

func generateReport(ctx *cli.Context) error {
	err := setup.SetContext(ctx, true)
	if err != nil {
		log.Fatalf("Could not initialize: %s", err.Error())
	}
	defer display.ClearProgress()

	display.InProgress(fmt.Sprint("Fetching Attribution Report"))

	locator := fossa.Locator{
		Fetcher:  config.Fetcher(),
		Project:  config.Project(),
		Revision: config.Revision(),
	}
	attrReport, err := fossa.GetReport(locator)
	if err != nil {
		return errors.Wrapf(err, "Unable to build report for for project %s:", locator)
	}

	if ctx.Bool(JSON) {
		output, err := json.Marshal(attrReport)
		if err != nil {
			return err
		}
		fmt.Println(string(output))
	} else {
		fmt.Printf(attributionTemplate, attrReport.Project.Name, attrReport.Project.Revision, renderDepListToString(attrReport.DirectDependencies), renderDepListToString(attrReport.DeepDependencies))
	}

	return nil
}

func renderDepListToString(reportRows []fossa.AttributionReportRow) string {
	tableString := &strings.Builder{}
	table := tablewriter.NewWriter(tableString)

	// Dep paths is a pain to render, so don't include them when rendering to console
	table.SetHeader([]string{"Package", "Source", "Version", "Hash", "Authors", "Description", "Licenses", "OtherLicenses", "ProjectURL", "Notes", "DownloadURL"})
	table.SetBorders(tablewriter.Border{Left: true, Top: true, Bottom: true, Right: true})
	table.SetRowLine(true)

	for _, row := range reportRows {
		source := row.Source
		if source == "git" && row.IsGolang {
			source = "go"
		}

		rowString := []string{row.Package, source, row.Version, row.Hash, convertSliceOfStringsToBullets(row.Authors), row.Description, renderDepLicensesToString(row.Licenses), renderDepLicensesToString(row.OtherLicenses), row.ProjectURL, convertSliceOfStringsToBullets(row.Notes), row.DownloadURL}

		table.Append(rowString)
	}
	table.Render()

	return tableString.String()
}

func sortStringArray(strs []string) {
	sortedStrings := strs
	sort.Strings(sortedStrings)
}

func convertSliceOfStringsToBullets(strs []string) string {
	sortStringArray(strs)
	bulletted := make([]string, 0, len(strs))
	for _, str := range strs {
		if str != "" {
			// if the bullet and str are not directly connected, the formatting can get weird (e.g. 2 bullets on one line, none on the next)
			bulletted = append(bulletted, fmt.Sprintf("*%s", str))
		}
	}

	return strings.Join(bulletted, "\n")
}

func renderDepLicensesToString(licenses []fossa.AttributionDependencyLicense) string {
	lics := make([]string, 0, len(licenses))
	for _, lic := range licenses {
		lics = append(lics, lic.Name)
	}

	return convertSliceOfStringsToBullets(lics)
}
